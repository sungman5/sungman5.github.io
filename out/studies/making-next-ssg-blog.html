<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link href="https://cdn.jsdelivr.net/gh/sunn-us/SUIT/fonts/static/woff2/SUIT.css" rel="stylesheet"/><link rel="preload" href="/_next/static/css/71c2a63c8bd56ca5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/71c2a63c8bd56ca5.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee7e63bc15b31913.js" defer=""></script><script src="/_next/static/chunks/framework-114634acb84f8baa.js" defer=""></script><script src="/_next/static/chunks/main-673a4fae4a27af6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-5abbab89529713a4.js" defer=""></script><script src="/_next/static/chunks/pages/studies/%5Bid%5D-edf40dee5f8f8fb6.js" defer=""></script><script src="/_next/static/2tZL7RCnXmlo3LJ1lH6zM/_buildManifest.js" defer=""></script><script src="/_next/static/2tZL7RCnXmlo3LJ1lH6zM/_ssgManifest.js" defer=""></script><style id="__jsx-61c897567e443a84">nav.jsx-61c897567e443a84{overflow-x:scroll;-ms-overflow-style:none}nav.jsx-61c897567e443a84::-webkit-scrollbar{display:none}.nav-list.jsx-61c897567e443a84{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-ms-flexbox;display:flex;gap:3rem;align-item:center}.nav-item.jsx-61c897567e443a84{font-size:1.8rem;font-family:"Fira Code",monospace}li.jsx-61c897567e443a84{list-style:none;text-indent:0;text-indent:-2rem;list-style-position:inside;padding-left:2.4rem}</style><style id="__jsx-b8fcc065d7c5d366">header.jsx-b8fcc065d7c5d366{margin-bottom:4rem}</style><style id="__jsx-52e9ad7e5d52fdfa">footer.jsx-52e9ad7e5d52fdfa{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-ms-flexbox;display:flex;gap:1.8rem;padding-top:2.4rem}</style></head><body><div id="__next"><main><header class="jsx-b8fcc065d7c5d366"><a class="logo" style="font-size:3.2rem;font-family:DungGeunMo;color:#000000" href="/"><img alt="UNICORN-IS-HERE" src="/img/unicorn_1f984.png" width="64" height="64" decoding="async" data-nimg="1" loading="lazy" style="color:transparent"/></a><nav class="jsx-61c897567e443a84"><ul class="jsx-61c897567e443a84 nav-list"><a href="/"><li style="color:#6e7781;text-decoration:none" class="jsx-61c897567e443a84 nav-item">all</li></a><a href="/studies"><li style="color:#0969da;text-decoration:underline" class="jsx-61c897567e443a84 nav-item">study</li></a><a href="/memo"><li style="color:#6e7781;text-decoration:none" class="jsx-61c897567e443a84 nav-item">memo</li></a><a target="_blank" style="display:flex;align-items:center" href="https://walterdesign.co.kr"><li style="color:#6e7781" class="jsx-61c897567e443a84 nav-item">works</li><img alt="open in new" src="/img/iconmonstr-external-link-thin.svg" width="16" height="16" decoding="async" data-nimg="1" loading="lazy" style="color:transparent;margin:0"/></a><a href="/about"><li style="color:#6e7781;text-decoration:none" class="jsx-61c897567e443a84 nav-item">about</li></a></ul></nav></header><article><div class="article-header"><p class="date">2023-01-19</p><h1 class="title">Next.js + github pages 정적 블로그를 만들며 배운 것들</h1><p class="excerpt">nextjs를 이용한 정적 블로그 생성할 때 알아두면 좋은 것들</p></div><div class="markdown-body"><p>Nextjs + github pages를 이용한 정적 블로그를 만들었다. 만들게 된 몇가지 이유가 있는데,</p>
<ul>
<li>점점 떨어지는 코딩 감각... NextJS/React/TypeScript 잘하진 못해도 감은 유지하자</li>
<li>ghost에 친화적이지 않은 국내 호스팅 환경이 불편해</li>
<li>디지털 오션에 쓰는 월 4천원이 아까워</li>
<li>블로그 포스팅으로라도 깃허브 잔디 심어보고 싶어</li>
<li>개발자라면 github 블로그 하나쯤은?</li>
</ul>
<p>뭐 이런 생각으로 별도의 템플릿을 사용하지 않고 무작정 개발을 시작했는데 생각보다 어렵고 헛갈렸다... 스스로 회고 시간을 가지면서 내가 부족했던 부분이 무엇이었는지 정리했다.</p>
<h3 id="블로그를-만들며-스스로-했던-질문들">블로그를 만들며 스스로 했던 질문들</h3>
<ul>
<li>정적 블로그는 무엇일까?</li>
<li>Next.js라는 리액트 프레임워크에서 정적 블로그는 어떤 방식과 흐름으로 포스팅을 발행하게 되는 걸까?</li>
<li>그 과정을 구현하는데 어떤 메소드를 사용해야 하는가?</li>
<li>그 메소드는 어떻게 사용하는가?</li>
</ul>
<h5 id="정적-블로그는-무엇일까">정적 블로그는 무엇일까?</h5>
<p>첫번째 질문에 대답하기 위해 생각해봐야 했던 것은 SSG(Static-Site-Generation)에 대한 개념이었다. 웹이 고도화되면서 사용자가 서버와 직접 통신하여 데이터를 주고 받고, 그 데이터에 따라 다양하게 구성되는 화면을 워낙 자연스럽게 접하다보니 '정적 사이트' 혹은 '정적 웹페이지'라는 개념이 내 머릿속에서 잠시 흐릿해졌던 것은 아닌가?</p>
<img src="https://d33wubrfki0l68.cloudfront.net/b0cd7be20ba718c92b5da007a109a89122f6791a/73909/v3/img/blog/ssg-host-flow.png" alt="정적사이트 흐름도" title="정적사이트 흐름도">
<p>개념을 다시 한 번 떠올려보자. 사용자에게 보여주는 페이지는 이미 만들어져 저장되어 있고, 사용자의 요청이 있을 때 요청에 해당하는 웹페이지를 보여줄 뿐, 운영자나 개발자가 데이터를 변경하지 않는다면 사용자는 매번 똑같은 화면을 보게된다. 흔히 <a href="http://wiki.hash.kr/index.php/%EC%9B%B9_1.0" target="_blank">WEB1.0</a>이라고 부르는 시대의 웹페이지들이 바로 정적 사이트라고 보면 된다. <strong>WEB1.0에서 운영자나 개발자는 정보를 수집/생성하고 디렉토리 기준으로 정리하여 사용자가 요청시마다 정해진 페이지를 일방적으로 보여준다.</strong></p>
<h5 id="정적-블로그는-어떻게-동작할까">정적 블로그는 어떻게 동작할까?</h5>
<p>Next.js의 <code>Pre-rendering</code>을 통해 정적 페이지를 생성한다는 개념을 이해해야 정적 블로그가 어떻게 작동하는지 이해할 수 있다. 마크다운으로 작성한 파일을 빌드시에 html 파일로 생성하여 배포한다. 블로그 작동 과정를 간단하게 정리하면 아래와 같다.</p>
<ol>
<li>사용자는 VS code와 같은 편집기를 이용하여 마크다운 파일(*.md, *.mdx) 형식으로 포스트를 작성한다.</li>
<li>배포를 위한 빌드시 해당 마크다운 파일(a.k.a 포스트)들을 <code>Pre-rendering</code>하여 html 페이지로 만들어낸다.</li>
<li>생성된 html 페이지를 Next.js의 <code>Dynamic Route</code>를 활용하여 라우팅한다.</li>
<li>요청시 사용자에게 생성된 html 페이지를  보여준다.</li>
</ol>
<h5 id="pre-rendering">Pre-rendering?</h5>
<p>Next.js의 특징 중 하나인 Pre-rendering에 관한 상세한 내용은 당연히 <a href="https://nextjs.org/learn/basics/data-fetching">공식문서</a>를 읽는 게 가장 좋다. 간단하게 말하자면 리액트처럼 자바스크립트로 클라이언트 쪽의 모든 작업을 수행하는 대신, 미리 생성할 수 있는 페이지나 데이터들을 미리 만들어 놨다가 사용자에게 빨리 보여 주자는 이야기. 보통 빌드될 때나, 요청이 있을 때 서버에서 만들어서 보여준다.</p>
<blockquote>
<p>기본적으로, Next.js의 <code>Pre-rendering</code>는 모든 페이지에서 일어난다. 이는 클라이언트 사이드에서 자바스크립트가 모든 작업을 하는 것을 대신해서, Next.js가 모든 페이지에서 HTML을 생성한다는 것을 의미한다. <code>Pre-rendering</code>은 더 나은 검색최적화(SEO) 퍼포먼스를 보여줄 수 있습니다. 즉, 페이지에서 자바스크립트가 필요 없는 부분은 미리 HTML을 생성하고, 자바스크립트는 꼭 필요한 최소한의 부분만 실행하여 인터렉티브한 페이지를 만드는 것이다. (이 과정을 <strong>hydration</strong>이라 부른다.)</p>
</blockquote>
<h5 id="실제-코드를-뜯어보며-작동-방식을-이해해-보자">실제 코드를 뜯어보며 작동 방식을 이해해 보자.</h5>
<ul>
<li>나의 마크다운 파일들은 <code>/posts/studies</code>에 모여있다.</li>
<li><code>/posts/studies</code> 폴더의 데이터는 <code>/pages/studies/[id]</code> 페이지에 출력된다.</li>
</ul>
<pre><code>export async function getStaticPaths() {
    const fs = require("fs");
    // 1️⃣ node.js의 fs(file system)모듈을 import한다.

    const files = fs.readdirSync('posts/studies');
    // 2️⃣ fs모듈의 readdirSync메소드를 이용하여 폴더안의 파일을 배열로 추출한다.

    const paths = files.map((element) => {        
        return {
            params: {
                id: element.replace(/\.md$/, ""),
            },
        };
    });
    // 3️⃣ map 함수를 사용하여 다이나믹 라우트의 [id]에 들어갈 값을 만든다.
    // 4️⃣ 파일 이름을 [id]로 사용하기 위해 파일이름에서 확장자 부분을 떼주는 과정을 포함했다.

    return {
        paths,
        fallback: false,
    }; 
    // 5️⃣ 리턴 값으로 paths 오브젝트와 fallback:false를 반환한다.
}
</code></pre>
<p><code>getStaticPath</code>를 이용하여 <code>[id]</code>에 사용될 <code>params</code>를 만들었다. 반환된 <code>paths</code>는 <code>getStaticProps</code>에 전달된다.</p>
<pre><code>export async function getStaticProps({ params }) {

    const id = params.id;
    // 1️⃣ getStaticPath로 부터 전달받은 params 오브젝트를 변수 id로 선언한다. 이 값은 리턴값에 포함된다.    

    const filePath = path.join('posts/studies', `${id}.md`);
    // 2️⃣ path.join를 활용하여 [id] 이름을 가진 파일을 변수로 선언한다.

    const fileContents = readFileSync(filePath, "utf-8");
    // 3️⃣ fs 모듈 중 readFileSync 메소드를 활용하여  
    // 'posts/studies/${id}.md' 파일의 내용을 fileContents 변수로 선언한다.

    const markdown = matter(fileContents);
    // 4️⃣ gray-matter의 matter 메소드를 활용하여 markdown 파일의 내용을
    // front-matter 부분과 content 부분으로 분리 가능하도록 파싱한다.

    const processedContent = await unified()
        .use(remarkGfm)
        .use(remarkParse)
        .use(remarkRehype, { allowDangerousHtml: true })
        .use(rehypeRaw)
        .use(rehypeSlug)
        .use(rehypeStringify)
        .process(markdown.content);

    const contentHtml = processedContent.toString();

    // 5️⃣ 포스팅의 분문 부분에 해당하는 markdown의 content 부분을
    // unified 메소드를 이용해 파싱하고, 문자열로 변경한다.

    return {
        props: {
            postData: {
                id,
                contentHtml,
                ...markdown.data,
            },
        },
    };
    // 6️⃣ getStaticPath에서 전달받은 경로(id), 포스팅 본문(contentHtml),
    // 포스팅 정보(...markdown.data)를 하나의 오브젝트로 생성하여 props로 컴포넌트에 전달한다.
}
</code></pre>
<h4 id="참조">참조</h4>
<p><a href="https://code-anthropoid.tistory.com/category/React/Next.js" style="display:block;" target="_blank">Next.js로 블로그 만들기</a>
<a href="https://velog.io/@taeung/Next.js-getStaticProps-%EC%82%AC%EC%9A%A9%EA%B8%B0" target="_blank" style="display:block;">Next.js getStaticProps 사용기</a>
<a href="https://velog.io/@chaewonkang/Next.js%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%8E%98%EC%B9%AD%EA%B3%BC-%EB%A0%8C%EB%8D%94%EB%A7%81" target="_blank" style="display:block;">Next.js의 데이터 페칭과 렌더링</a></p></div><section class="comments"></section></article><footer class="jsx-52e9ad7e5d52fdfa"><p style="font-size:1.4rem" class="jsx-52e9ad7e5d52fdfa">©UNICORN-IS-HERE <!-- -->2023</p><a title="별거없지만 깃허브 방문하기" target="_blank" href="https://github.com/sungman5"><img alt="https://github.com/sungman5" src="/img/iconmonstr-github-1.svg" width="24" height="24" decoding="async" data-nimg="1" loading="lazy" style="color:transparent"/></a><a title="문의 메일 보내기" target="_blank" href="mailto:sungman5@gmail.com"><img alt="sungman5@gmail.com" src="/img/iconmonstr-email-4.svg" width="24" height="24" decoding="async" data-nimg="1" loading="lazy" style="color:transparent"/></a></footer></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"making-next-ssg-blog","contentHtml":"\u003cp\u003eNextjs + github pages를 이용한 정적 블로그를 만들었다. 만들게 된 몇가지 이유가 있는데,\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e점점 떨어지는 코딩 감각... NextJS/React/TypeScript 잘하진 못해도 감은 유지하자\u003c/li\u003e\n\u003cli\u003eghost에 친화적이지 않은 국내 호스팅 환경이 불편해\u003c/li\u003e\n\u003cli\u003e디지털 오션에 쓰는 월 4천원이 아까워\u003c/li\u003e\n\u003cli\u003e블로그 포스팅으로라도 깃허브 잔디 심어보고 싶어\u003c/li\u003e\n\u003cli\u003e개발자라면 github 블로그 하나쯤은?\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e뭐 이런 생각으로 별도의 템플릿을 사용하지 않고 무작정 개발을 시작했는데 생각보다 어렵고 헛갈렸다... 스스로 회고 시간을 가지면서 내가 부족했던 부분이 무엇이었는지 정리했다.\u003c/p\u003e\n\u003ch3 id=\"블로그를-만들며-스스로-했던-질문들\"\u003e블로그를 만들며 스스로 했던 질문들\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e정적 블로그는 무엇일까?\u003c/li\u003e\n\u003cli\u003eNext.js라는 리액트 프레임워크에서 정적 블로그는 어떤 방식과 흐름으로 포스팅을 발행하게 되는 걸까?\u003c/li\u003e\n\u003cli\u003e그 과정을 구현하는데 어떤 메소드를 사용해야 하는가?\u003c/li\u003e\n\u003cli\u003e그 메소드는 어떻게 사용하는가?\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch5 id=\"정적-블로그는-무엇일까\"\u003e정적 블로그는 무엇일까?\u003c/h5\u003e\n\u003cp\u003e첫번째 질문에 대답하기 위해 생각해봐야 했던 것은 SSG(Static-Site-Generation)에 대한 개념이었다. 웹이 고도화되면서 사용자가 서버와 직접 통신하여 데이터를 주고 받고, 그 데이터에 따라 다양하게 구성되는 화면을 워낙 자연스럽게 접하다보니 '정적 사이트' 혹은 '정적 웹페이지'라는 개념이 내 머릿속에서 잠시 흐릿해졌던 것은 아닌가?\u003c/p\u003e\n\u003cimg src=\"https://d33wubrfki0l68.cloudfront.net/b0cd7be20ba718c92b5da007a109a89122f6791a/73909/v3/img/blog/ssg-host-flow.png\" alt=\"정적사이트 흐름도\" title=\"정적사이트 흐름도\"\u003e\n\u003cp\u003e개념을 다시 한 번 떠올려보자. 사용자에게 보여주는 페이지는 이미 만들어져 저장되어 있고, 사용자의 요청이 있을 때 요청에 해당하는 웹페이지를 보여줄 뿐, 운영자나 개발자가 데이터를 변경하지 않는다면 사용자는 매번 똑같은 화면을 보게된다. 흔히 \u003ca href=\"http://wiki.hash.kr/index.php/%EC%9B%B9_1.0\" target=\"_blank\"\u003eWEB1.0\u003c/a\u003e이라고 부르는 시대의 웹페이지들이 바로 정적 사이트라고 보면 된다. \u003cstrong\u003eWEB1.0에서 운영자나 개발자는 정보를 수집/생성하고 디렉토리 기준으로 정리하여 사용자가 요청시마다 정해진 페이지를 일방적으로 보여준다.\u003c/strong\u003e\u003c/p\u003e\n\u003ch5 id=\"정적-블로그는-어떻게-동작할까\"\u003e정적 블로그는 어떻게 동작할까?\u003c/h5\u003e\n\u003cp\u003eNext.js의 \u003ccode\u003ePre-rendering\u003c/code\u003e을 통해 정적 페이지를 생성한다는 개념을 이해해야 정적 블로그가 어떻게 작동하는지 이해할 수 있다. 마크다운으로 작성한 파일을 빌드시에 html 파일로 생성하여 배포한다. 블로그 작동 과정를 간단하게 정리하면 아래와 같다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e사용자는 VS code와 같은 편집기를 이용하여 마크다운 파일(*.md, *.mdx) 형식으로 포스트를 작성한다.\u003c/li\u003e\n\u003cli\u003e배포를 위한 빌드시 해당 마크다운 파일(a.k.a 포스트)들을 \u003ccode\u003ePre-rendering\u003c/code\u003e하여 html 페이지로 만들어낸다.\u003c/li\u003e\n\u003cli\u003e생성된 html 페이지를 Next.js의 \u003ccode\u003eDynamic Route\u003c/code\u003e를 활용하여 라우팅한다.\u003c/li\u003e\n\u003cli\u003e요청시 사용자에게 생성된 html 페이지를  보여준다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch5 id=\"pre-rendering\"\u003ePre-rendering?\u003c/h5\u003e\n\u003cp\u003eNext.js의 특징 중 하나인 Pre-rendering에 관한 상세한 내용은 당연히 \u003ca href=\"https://nextjs.org/learn/basics/data-fetching\"\u003e공식문서\u003c/a\u003e를 읽는 게 가장 좋다. 간단하게 말하자면 리액트처럼 자바스크립트로 클라이언트 쪽의 모든 작업을 수행하는 대신, 미리 생성할 수 있는 페이지나 데이터들을 미리 만들어 놨다가 사용자에게 빨리 보여 주자는 이야기. 보통 빌드될 때나, 요청이 있을 때 서버에서 만들어서 보여준다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e기본적으로, Next.js의 \u003ccode\u003ePre-rendering\u003c/code\u003e는 모든 페이지에서 일어난다. 이는 클라이언트 사이드에서 자바스크립트가 모든 작업을 하는 것을 대신해서, Next.js가 모든 페이지에서 HTML을 생성한다는 것을 의미한다. \u003ccode\u003ePre-rendering\u003c/code\u003e은 더 나은 검색최적화(SEO) 퍼포먼스를 보여줄 수 있습니다. 즉, 페이지에서 자바스크립트가 필요 없는 부분은 미리 HTML을 생성하고, 자바스크립트는 꼭 필요한 최소한의 부분만 실행하여 인터렉티브한 페이지를 만드는 것이다. (이 과정을 \u003cstrong\u003ehydration\u003c/strong\u003e이라 부른다.)\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch5 id=\"실제-코드를-뜯어보며-작동-방식을-이해해-보자\"\u003e실제 코드를 뜯어보며 작동 방식을 이해해 보자.\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e나의 마크다운 파일들은 \u003ccode\u003e/posts/studies\u003c/code\u003e에 모여있다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e/posts/studies\u003c/code\u003e 폴더의 데이터는 \u003ccode\u003e/pages/studies/[id]\u003c/code\u003e 페이지에 출력된다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003eexport async function getStaticPaths() {\n    const fs = require(\"fs\");\n    // 1️⃣ node.js의 fs(file system)모듈을 import한다.\n\n    const files = fs.readdirSync('posts/studies');\n    // 2️⃣ fs모듈의 readdirSync메소드를 이용하여 폴더안의 파일을 배열로 추출한다.\n\n    const paths = files.map((element) =\u003e {        \n        return {\n            params: {\n                id: element.replace(/\\.md$/, \"\"),\n            },\n        };\n    });\n    // 3️⃣ map 함수를 사용하여 다이나믹 라우트의 [id]에 들어갈 값을 만든다.\n    // 4️⃣ 파일 이름을 [id]로 사용하기 위해 파일이름에서 확장자 부분을 떼주는 과정을 포함했다.\n\n    return {\n        paths,\n        fallback: false,\n    }; \n    // 5️⃣ 리턴 값으로 paths 오브젝트와 fallback:false를 반환한다.\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003egetStaticPath\u003c/code\u003e를 이용하여 \u003ccode\u003e[id]\u003c/code\u003e에 사용될 \u003ccode\u003eparams\u003c/code\u003e를 만들었다. 반환된 \u003ccode\u003epaths\u003c/code\u003e는 \u003ccode\u003egetStaticProps\u003c/code\u003e에 전달된다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eexport async function getStaticProps({ params }) {\n\n    const id = params.id;\n    // 1️⃣ getStaticPath로 부터 전달받은 params 오브젝트를 변수 id로 선언한다. 이 값은 리턴값에 포함된다.    \n\n    const filePath = path.join('posts/studies', `${id}.md`);\n    // 2️⃣ path.join를 활용하여 [id] 이름을 가진 파일을 변수로 선언한다.\n\n    const fileContents = readFileSync(filePath, \"utf-8\");\n    // 3️⃣ fs 모듈 중 readFileSync 메소드를 활용하여  \n    // 'posts/studies/${id}.md' 파일의 내용을 fileContents 변수로 선언한다.\n\n    const markdown = matter(fileContents);\n    // 4️⃣ gray-matter의 matter 메소드를 활용하여 markdown 파일의 내용을\n    // front-matter 부분과 content 부분으로 분리 가능하도록 파싱한다.\n\n    const processedContent = await unified()\n        .use(remarkGfm)\n        .use(remarkParse)\n        .use(remarkRehype, { allowDangerousHtml: true })\n        .use(rehypeRaw)\n        .use(rehypeSlug)\n        .use(rehypeStringify)\n        .process(markdown.content);\n\n    const contentHtml = processedContent.toString();\n\n    // 5️⃣ 포스팅의 분문 부분에 해당하는 markdown의 content 부분을\n    // unified 메소드를 이용해 파싱하고, 문자열로 변경한다.\n\n    return {\n        props: {\n            postData: {\n                id,\n                contentHtml,\n                ...markdown.data,\n            },\n        },\n    };\n    // 6️⃣ getStaticPath에서 전달받은 경로(id), 포스팅 본문(contentHtml),\n    // 포스팅 정보(...markdown.data)를 하나의 오브젝트로 생성하여 props로 컴포넌트에 전달한다.\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"참조\"\u003e참조\u003c/h4\u003e\n\u003cp\u003e\u003ca href=\"https://code-anthropoid.tistory.com/category/React/Next.js\" style=\"display:block;\" target=\"_blank\"\u003eNext.js로 블로그 만들기\u003c/a\u003e\n\u003ca href=\"https://velog.io/@taeung/Next.js-getStaticProps-%EC%82%AC%EC%9A%A9%EA%B8%B0\" target=\"_blank\" style=\"display:block;\"\u003eNext.js getStaticProps 사용기\u003c/a\u003e\n\u003ca href=\"https://velog.io/@chaewonkang/Next.js%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%8E%98%EC%B9%AD%EA%B3%BC-%EB%A0%8C%EB%8D%94%EB%A7%81\" target=\"_blank\" style=\"display:block;\"\u003eNext.js의 데이터 페칭과 렌더링\u003c/a\u003e\u003c/p\u003e","title":"Next.js + github pages 정적 블로그를 만들며 배운 것들","date":"2023-01-19","excerpt":"nextjs를 이용한 정적 블로그 생성할 때 알아두면 좋은 것들","author":"Walter","category":"studies"}},"__N_SSG":true},"page":"/studies/[id]","query":{"id":"making-next-ssg-blog"},"buildId":"2tZL7RCnXmlo3LJ1lH6zM","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>